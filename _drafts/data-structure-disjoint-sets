---
layout: post
title: Data Structure: Disjoint-Sets
---

The most common use I have found for this data structure is to determine if adding a specific edge to a graph would form a cycle.
In Kruskal's algorithm, it is used in this way to build a minimal spanning tree.
Building a maze is similar to applying Kruskal's algorithm.
I'll visit how to build a maze this way in the future.
This article will discuss the data structure.

In mathematics, sets are disjoint if they have no members in common.
Think of a Disjoint Sets data structure as a collection of such sets.
Once you initialize the data structure with the number of sets, there are only two supported operations: you can ask the data structure which set an element is in and you can merge two of the sets.
The data structure is sometimes called "Union-Find" after these operations.

To use the `find` operation, you must understand the notion of a "representative" element.
The data structure chooses one element as the representative for a set.
So if element *a* and elememnt *b* are in the same set, and the data structure has choosen *a* as the representative, then both `disjointSets.find(a)` and `disjointSets.find(b)` will both return *a*.

## Usage

In C++, the public part of a class interface for such a data structure might look something like this:

```cpp
class DisjointSets {
    public:
        DisjointSets(size_t numSets);
        size_t findSet(size_t element);
        void unionSets(size_t set1, size_t set2);
};
```

Note that we are dealing with elements of type `size_t`.
If there is satellite data it can be stored elsewhere in a vector indexed by these elements.
This keeps the implementation simple.

Upon creation, there will be `numSets` sets, each containing one element, the representative for that set.
That means that initially, `findSet(n)` returns n for all n < numSets.

Now if we call `unionSets(0,1)`, then `findSet(0)` and `findSet(1)` will both return 0 or both return 1, depending on the implementation.
This return value is the representative for the new set containing 0 and 1.
If we then call `unionSets(findSet(0), 2)` there will be one set that contains {0,1,2} and single-element sets for each of the remaining elements > 2.
Note that `unionSets()` takes representatives as arguments.
So we can't simply call `unionSets(0,2)` after we called `unionSets(0,1)` because the representative for that first set may be 0 or 1.

If we continue to call `unionSets(findSet(0), n)` repeatedly for the rest of the values of n < numSets-1, `findSet(n)` will return the same value for every n because there will be only one set.

## Implementation

The way I have chosen to implement this is to use a `vector<size_t>` where each element contains either its own index position, indicating that it is a representative, or the index to a different position in the vector which should be used as a link to follow to find the representative.
Links are followed this way until an index is found that "points" to itself, indicating that it is the representative.
For example, the vector v is initialized as `{0,1,2,3,...,numSets-1}`.

Each element contains its own index.
This means each set contains one element and representative for set n is n because v[n] == n.
Once we call `unionSets(0,1)` the vector will look like this: `{0,0,2,3,...,numSets-1}`.
v[1] "points" to v[0] and v[0] points to itself, so 0 is the representative of the set {0,1}.
`findSet(0)` and `findSet(1)` both return 0.

To continue the example, if we then call `unionSets(0,2)`, the vector will look like this: `{0,0,2,3,...,numSets-1}`.
v[2] points to v[1] and v[1] points to v[0] and v[0] points to itself.
So 0 is the representative for the set containing {0,1,2}.
Note that the vector could also be represented as `{0,0,0,3,...,numSets-1}` and the result would be the same: v[1] and v[2] both point to their representative.
This is an implementation detail that we will discuss later.


